# 개요
파이썬 코딩 테스트에서 많이 사용하는 문법을 정리하였다.

## 입출력 문법
```
# 문자열  입력 받기
user_id = input().strip()

# 문자열 숫자로 변환하기
ad_year = int(input().strip())

# 세 정수를 입력받기
A, B, C = map(int, input().split())

# 입력 받은 정수를 리스트로 입력
numbers = list(map(int, input().split()))

print(user_id + "??!")

print(ad_year)

result = A + B + C
print(result)

baskets = list(range(1, 6))

print(baskets)     # [1, 2, 3, 4, 5]
print(*baskets)    # 1 2 3 4 5

# 구분자 바꾸기
print(*baskets, sep=",")   # 1,2,3,4,5
print(*baskets, sep="-")   # 1-2-3-4-5


```

## 연산 문법
```
result = sum // 60   # 60 으로 나누었을 경우 정수 까지만 결과 리턴

result = max(a, b, c)   # a, b, c 중 최대값 리턴

result = "long " * count + "int" # long 문자열을 count 수 만큼 생성

count = numbers.count(v)    # numbers 리스트에서 v의 개수 count 저장

# 파이썬 특유의 튜플 언패킹을 이용한 값 교환
baskets[i-1], baskets[j-1] = baskets[j-1], baskets[i-1]

# baskets[i-1:j] : i번째부터 j번째 바구니 (인덱스 보정 필요)
# baskets[::-1] : 리스트를 거꾸로 뒤집는 파이썬의 간단한 문법
baskets[i-1:j] = baskets[i-1:j][::-1] # 선택 구간만 역순으로 교체

for _ in range(T):
    s = input().strip()   # 문자열 입력받기
    print(s[0] + s[-1])   # 첫 글자와 마지막 글자 출력


```

## if, else
```
if total == X:
    print("Yes")
elif total > 10:
    print("over 10")
else:
    print("No")

```


## for, while 문법
```
for _ in range(N):
    a, b = map(int, input().split())

```

## set() 활용
```
# 전체 학생 집합
all_students = set(range(1, 31))

# 제출 학생 집합
submitted = set(int(input()) for _ in range(28))

# 제출하지 않은 학생
not_submitted = all_students - submitted

# 작은 번호부터 출력
for student in sorted(not_submitted):
    print(student)

```

## 함수 선언 명시적 표현
```
def fib_count(n: int) -> int:
```

## 피보나치 수열(재귀함수), 동적프로그래밍
```
fib(n):
    if n == 1 or n == 2:
        return 1   # 코드1 실행
    else:
        return fib(n-1) + fib(n-2)

fibonacci(n):
    f[1] = f[2] = 1
    for i in range(3, n+1):
        f[i] = f[i-1] + f[i-2]   # 코드2 실행

```

## BFS
```
from collections import deque

# 입력 받기
N, M = map(int, input().split())
maze = [list(map(int, input().strip())) for _ in range(N)]

# 방향 (상, 하, 좌, 우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# BFS 함수 정의
def bfs(x, y):
    queue = deque()
    queue.append((x, y))

    while queue:
        x, y = queue.popleft()
        # 네 방향 탐색
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            # 범위 확인
            if 0 <= nx < N and 0 <= ny < M:
                # 이동 가능하고 아직 방문하지 않았다면
                if maze[nx][ny] == 1:
                    maze[nx][ny] = maze[x][y] + 1  # 거리 갱신
                    queue.append((nx, ny))

    # 도착 지점의 값 반환
    return maze[N-1][M-1]

# BFS 실행 및 출력
print(bfs(0, 0))

```